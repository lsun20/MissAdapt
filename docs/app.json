[{"name":"app.R","content":"# Load necessary libraries\nlibrary(shiny)\nlibrary(bslib)\nsource(\"grid.R\")\nlibrary(ggplot2)\nlibrary(tidyverse)\n# Define color and linetype preferences\ncbp1 <- c(\"#999999\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\")\nmy_linetypes <- c('solid', 'dotted', 'dashed', 'dotdash','longdash')\nmy_linetypes2 <- c('solid', 'solid', 'dashed', 'dotdash','longdash')\n\nlibrary(latex2exp)\n# Define UI for application\nui <- fluidPage(\n  \n  # Application title\n  titlePanel(\"Adaptive Soft Threshold for Combining Unrestricted and Restricted Estimates\"),\n  # Description line below the title\n  h4(\"Shiny App based on the MissAdapt repository.\"),\n  h4(\"Adapts to bias due to potential misspecification of the restriction via soft-thresholding.\"),\n  h4(\"For more functionality refer to the vignette on\", a(\"GitHub.\", \n  href = \"https://github.com/lsun20/MissAdapt\",target=\"_blank\", rel=\"noreferrer noopener\")),\n  \n \n      fluidRow(\n        column(6, numericInput(\"YU\", \"Unrestricted estimate (YU):\", value = 0.43)),\n        column(6, numericInput(\"sigmaU\", \"Standard error (sigmaU):\", value = 0.14))\n      ),\n      fluidRow(\n        column(6, numericInput(\"YR\", \"Restricted estimate (YR):\", value = 0.26)),\n        column(6, numericInput(\"sigmaR\", \"Standard error (sigmaR):\", value = 0.09))\n      ),\n  fluidRow(\n    column(6,numericInput(\"VUR\", \"Cov(YU,YR) (default assumes YR is efficient, and sets to sigmaR^2):\", value = 0.09^2, step = 0.1)),\n           column(6, actionButton(\"compute\", \"Adapt\"))\n    ),\n    \n    fluidRow(\n             div(\n               style = \"display: flex; justify-content: center; flex-direction: column; align-items: center;\",\n               conditionalPanel(\n                 condition = \"input.compute > 0\",\n                 h4(\"Summary of the Adaptation Results\"),\n                 tableOutput(\"values\")\n               )\n             )\n    ),\n    fluidRow(\n      column(12,\n             div(\n               conditionalPanel(\n                 style = \"margin-top: 10px;\",\n                 condition = \"input.compute > 0\",\n                 h4(\"Explanation for Adaptation\"),\n                 tags$ul(\n                   tags$li(textOutput(\"corr_output\")),\n                   tags$li(textOutput(\"st_output\")),\n                   tags$li(textOutput(\"estimate_output\"))\n                 )\n               )\n             )\n        )\n      ),\n      fluidRow(\n        div(\n          style = \"display: flex; justify-content: center; flex-direction: column; align-items: center;\",\n          plotOutput('plot', width = \"400px\", height = \"300px\")\n        )\n      )\n    \n  \n)\n\n# Define server logic\nserver <- function(input, output,session) {\n  observe({\n    # Update VUR to default value based on sigmaR\n    updateNumericInput(session, \"VUR\", value = input$sigmaR^2)\n  })\n  observeEvent(input$compute, {\n    YU <- as.numeric(input$YU)\n    sigmaU <- as.numeric(input$sigmaU)\n    YR <- as.numeric(input$YR)\n    sigmaR <- as.numeric(input$sigmaR)\n    VUR <- as.numeric(input$VUR)\n    \n    VU <- sigmaU^2\n    VR <- sigmaR^2\n    VO <- VR - 2 * VUR + VU\n    VUO <- (VUR - VU)\n    corr <- VUO / sqrt(VO) / sqrt(VU)\n  \n  \n  Sigma_UO_grid <- abs(tanh(seq(-3, -0.05, 0.05)))\n  \n  st.function <- splinefun(Sigma_UO_grid, st_thresholds_grid, method = \"fmm\", ties = mean)\n  st <- st.function(abs(corr))\n  \n  YO <- YR - YU\n  tO <- YO / sqrt(VO)\n  GMM <- YU - VUO / VO * YO; V_GMM <- VU - VUO/VO*VUO;\n  adaptive_st <- VUO / sqrt(VO) * ((tO > st) * (tO - st) + (tO < -st) * (tO + st)) + GMM\n  decimal <- match(TRUE, round(YU, 1:20) == YU)\n  adaptive_st <- round(adaptive_st,decimal)\n  tO <- round(tO,decimal)\n  GMM <- round(GMM,decimal)\n  # Add soft threshold risk functions\n  Eb <- function(l) 1 + l^2 + (b_grid^2 - 1 - l^2) * (pnorm(l - b_grid) - pnorm(-l - b_grid)) + (-b_grid - l) * dnorm(l - b_grid) - (l - b_grid) * dnorm(-l - b_grid)\n  \n  risk_function_st <- corr^2 * Eb(st) + 1 - corr^2 \n  risk_oracle <- corr^2 * rho_b_over_sigma + 1 - corr^2\n  \n  regret_st <- round(max(risk_function_st/risk_oracle),2)-1\n  \n  # Use simulation to calculate the risk function for the pre-test estimator that switches btw Y_U and Y_R\n  # sims <- 100000\n  # x <- rnorm(sims, 0, 1)\n  # x_b <- outer(x, as.vector(b_grid), \"+\")\n  # Ebsims_ht <- function(l) {\n  #   colMeans(((x_b > l) * x_b + ((x_b < l & x_b > -l) * x_b) * (1 + VO/VUO) + (x_b < -l) * x_b\n  #             - matrix(rep(b_grid, sims), ncol = length(b_grid), byrow = TRUE))^2)\n  # }\n  # risk_function_ht_ttest <- corr^2 * Ebsims_ht(1.96) + 1 - corr^2\n  \n  # Calculate the risk function for the pre-test estimator that switches btw Y_U and GMM\n  # Eb_ht <-function(l){\n  #   1+(b_grid^2-1)*(pnorm(l-b_grid)-pnorm(-l-b_grid))+(l-b_grid)*dnorm(l-b_grid) - (-l-b_grid)*dnorm(-l-b_grid);\n  # } \n  # risk_function_ht_ttest <- corr^2 * Eb_ht(1.96) + 1 - corr^2\n  \n  # regret_ht <- round(max(risk_function_ht_ttest/risk_oracle),2)-1\n  # Show the values in an HTML table ----\n  output$values <- renderTable({\n    data.frame(\n      Estimator = c(\"Estimate\", \"Std Error\", \"Max Regret\", \"Threshold\"),\n      Y_U = c(YU, paste(\"(\",sigmaU,\")\",sep=\"\"), paste(100*round(1/(1-corr^2)-1,2), \"%\", sep=\"\"), NA),\n      Y_R = c(YR, paste(\"(\",sigmaR,\")\",sep=\"\"), \"âˆž\", NA),\n      # Adaptive = c(0.36, NA, \"44%\", NA),\n      Soft_threshold = c(adaptive_st, NA, paste(regret_st*100, \"%\", sep=\"\"), round(st,2)),\n      # Pre_test = c(0.26, NA, paste(regret_ht*100, \"%\", sep=\"\"), \"1.96\"),\n      stringsAsFactors = FALSE)\n  })\n  \n  # Create a data frame of only adaptive risk\n  # Plot the figure\n  b_grid_scale <- sign(b_grid)*sqrt(abs(b_grid));\n  df <- data.frame(\n    b_grid_scale = b_grid_scale,\n    a = rep(1, Kb),\n    b = risk_function_st,\n    # c = risk_function_ht_ttest,\n    e = risk_oracle\n  )\n  \n  # Melt the data frame to long format\n  df_long <- tidyr::gather(df, key = \"series\", value = \"y\", -b_grid_scale)\n  \n  output$plot <- renderPlot({\n    par(mar = c(5, 5, 4, 5), pty = 'm',cex=1.2)  # Adjust margins as needed\n    \n    # Plotting using ggplot2\n    ggplot(df_long, aes(x = b_grid_scale, y = y, linetype = series, color = series)) +\n      geom_line(size=1.2) +\n      labs(x = TeX(\"b/$\\\\sigma_O$\"), y = TeX(\"MSE Relative to $\\\\sigma^2_U$\"), title = NULL) +\n      scale_x_continuous(breaks = c(-3, -2, -1, 0, 1, 2, 3), labels = c('-9', '-4', '-1', '0', '1', '4', '9')) +\n      ylim(c(min(risk_oracle-0.1), max(risk_function_st)+0.1)) +\n      theme_minimal() +\n      theme(\n        legend.position = \"bottom\",\n        legend.direction = \"horizontal\",\n        legend.box = \"horizontal\",\n        legend.text = element_text(size = 12),  # Adjust legend text size\n        axis.text = element_text(size = 14),\n        axis.title = element_text(size = 14)\n      ) +\n      scale_color_manual(values = cbp1, name = \"\",\n                         labels = c(TeX('$Y_U$'),TeX('Adaptive soft-threshold'),'Oracle')) +\n      scale_linetype_manual(values = my_linetypes2, name = \"\",\n                            labels = c(TeX('$Y_U$'),TeX('Adaptive soft-threshold'),'Oracle')) +\n      guides(color = guide_legend(ncol = 3))\n  })\n  \n  output$corr_output <- renderText({\n    paste(\"The correlation coefficient between YU and (YR-YU) is \", paste(round(corr,2),\",\",sep=\"\"),\n          \"which implies the efficient GMM estimate when YR is correctly specified is \",GMM,\n          \" and the efficiency of YU relative to the efficient GMM estimate is \", paste(round(1-corr^2,2),\".\",sep=\"\"),\n          \"If YR is subject to potential bias, then the line labeled ''oracle'' in the figure below illustrates the smallest possible risk that can be achieved when only a bound on the bias magnitude is known.\",\n          \"Adaptation seeks to minimize the maximum regret, which is the worst-case deviation from this oracle risk function.\")\n  })\n  output$st_output <- renderText({\n    paste(\"Given the relative efficiency of YU and the efficient GMM, the soft threshold that achieves optimal adaptation is \", paste(round(st,2),\".\",sep=\"\"), \"The maximum regret in this case is\",paste(regret_st*100, \"%.\", sep=\"\"))\n  })\n  \n  if (-st < tO & tO < st) {\n    output$estimate_output <- renderText({\n      paste(\"Since (YR-YU)/std(YR-YU) = \",tO,\n            \"does not exceed the threshold, the adaptive soft thresholding estimator maintains to be the efficient GMM estimate, yielding\",\n            paste(adaptive_st,\".\",sep=\"\"))\n      })\n  }\n  if (tO <=-st ) {\n    output$estimate_output <- renderText({\n      paste(\"Since (YR-YU)/std(YR-YU) = \",tO,\n            \"is negative and below the threshold, the adaptive soft thresholding estimator translates YU toward the GMM efficient estimate, yielding\",\n            paste(adaptive_st,\".\",sep=\"\"))\n    })\n  }\n  if (tO >= st ) {\n    output$estimate_output <- renderText({\n      paste(\"Since (YR-YU)/std(YR-YU) = \",tO,\n            \"is positive and above the threshold, the adaptive soft thresholding estimator translates YU toward the efficient GMM estimate, yielding\",\n            paste(adaptive_st,\".\",sep=\"\"))\n    })\n  }\n  })\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n","type":"text"},{"name":"grid.R","content":"# Precompute the function\nst_thresholds_grid <- c(1.57482766198508, 1.55125499909256, 1.52742074353448, 1.50334882329505, 1.47906233490077, \n                        1.45458150029266, 1.4299270409132, 1.40512383967876, 1.38019303478176, 1.35515605260822, \n                        1.33003227704614, 1.30483757026634, 1.27959849366401, 1.25433502048039, 1.22906433002374, \n                        1.20379862855458, 1.17856184780166, 1.15337076343841, 1.12824236155291, 1.10319422804627, \n                        1.07824432631491, 1.05340561586754, 1.02870454439195, 1.00416561484403, 0.979813578603983, \n                        0.955673742841495, 0.931764912197942, 0.908115155200027, 0.884752852219577, 0.861705205296034, \n                        0.838984986407601, 0.816633434009214, 0.794675112145209, 0.7731297065466, 0.752040905293611, \n                        0.731416663001888, 0.711309030584423, 0.69172503640683, 0.672713172851095, 0.654291308290986, \n                        0.636491137084625, 0.619350676770425, 0.602881936878391, 0.58712468096191, 0.57210936993747, \n                        0.557856650375231, 0.544387216517243, 0.531735712033272, 0.519924940086376, 0.508976432315778, \n                        0.498906428201768, 0.489732214564344, 0.481477367692955, 0.474157387541963, 0.467784346318755, \n                        0.462372207805892, 0.457930286791032, 0.454466861185033, 0.451997110894451, 0.450509551844624)\n\nB = 9;\nb_grid <- seq(-B, B, 0.05)\nKb <- length(b_grid)\n\nrho_tbl <- data.frame(\n  V1 = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0,\n         1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0,\n         2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3.0,\n         3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4.0,\n         4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5.0,\n         5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8, 5.9, 6.0,\n         6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8, 6.9, 7.0,\n         7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8, 7.9, 8.0,\n         8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7, 8.8, 8.9, 9.0),\n  V2 = c(0.009901078, 0.038461442, 0.082545237, 0.137720131, 0.199021684, 0.261577440,\n         0.321039555, 0.373847194, 0.417355386, 0.449863204, 0.471754896, 0.492436768,\n         0.513709998, 0.535200837, 0.556503872, 0.577192094, 0.596829224, 0.614983746,\n         0.631243828, 0.645232190, 0.657717288, 0.669912144, 0.681801925, 0.693338275,\n         0.704481717, 0.715127809, 0.725188312, 0.734563050, 0.743139180, 0.751149978,\n         0.758888139, 0.766359368, 0.773569395, 0.780507459, 0.787155471, 0.793481507,\n         0.799462342, 0.805082646, 0.810476732, 0.815679281, 0.820700443, 0.825541810,\n         0.830203342, 0.834677332, 0.838959389, 0.843039315, 0.846958242, 0.850744867,\n         0.854403240, 0.857937710, 0.861351001, 0.864643190, 0.867813003, 0.870858050,\n         0.873796003, 0.876638978, 0.879392738, 0.882059029, 0.884640495, 0.887138219,\n         0.889551698, 0.891883875, 0.894141903, 0.896333082, 0.898458833, 0.900521492,\n         0.902523491, 0.904465166, 0.906347814, 0.908173076, 0.909945978, 0.911669917,\n         0.913346272, 0.914975637, 0.916560359, 0.918101263, 0.919598463, 0.921054623,\n         0.922472144, 0.923852643, 0.925197859, 0.926507996, 0.927784307, 0.929027313,\n         0.930238665, 0.931419094, 0.932569572, 0.933692931, 0.934788964, 0.935857989)\n)\n\nrho_b_over_sigma_function<- splinefun(rho_tbl$V1, rho_tbl$V2, method = \"fmm\", ties = mean)\nrho_b_over_sigma <- rho_b_over_sigma_function(abs(b_grid))\n\n","type":"text"}]
